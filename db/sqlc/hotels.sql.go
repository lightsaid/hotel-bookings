// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: hotels.sql

package db

import (
	"context"
	"database/sql"
)

const DeleteHotelByID = `-- name: DeleteHotelByID :exec
UPDATE hotels SET is_deleted = 1, updated_at = NOW() WHERE id = ? and is_deleted = 0
`

func (q *Queries) DeleteHotelByID(ctx context.Context, id uint32) error {
	_, err := q.db.ExecContext(ctx, DeleteHotelByID, id)
	return err
}

const GetHotelByID = `-- name: GetHotelByID :one
SELECT id, title, code, address, created_at, updated_at, is_deleted FROM hotels WHERE id = ? AND is_deleted = 0
`

func (q *Queries) GetHotelByID(ctx context.Context, id uint32) (*Hotel, error) {
	row := q.db.QueryRowContext(ctx, GetHotelByID, id)
	var i Hotel
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Code,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
	)
	return &i, err
}

const GetHotels = `-- name: GetHotels :many
SELECT id, title, code, address, created_at, updated_at, is_deleted FROM hotels WHERE is_deleted = 0 ORDER BY id LIMIT ? OFFSET ?
`

type GetHotelsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetHotels(ctx context.Context, arg GetHotelsParams) ([]*Hotel, error) {
	rows, err := q.db.QueryContext(ctx, GetHotels, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Hotel{}
	for rows.Next() {
		var i Hotel
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Code,
			&i.Address,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetHotelsByTitle = `-- name: GetHotelsByTitle :many
SELECT id, title, code, address, created_at, updated_at, is_deleted FROM hotels WHERE title LIKE ? AND is_deleted = 0 ORDER BY id LIMIT ? OFFSET ?
`

type GetHotelsByTitleParams struct {
	Title  string `json:"title"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetHotelsByTitle(ctx context.Context, arg GetHotelsByTitleParams) ([]*Hotel, error) {
	rows, err := q.db.QueryContext(ctx, GetHotelsByTitle, arg.Title, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Hotel{}
	for rows.Next() {
		var i Hotel
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Code,
			&i.Address,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const InsertHotel = `-- name: InsertHotel :execresult
INSERT INTO hotels (title, code, address) VALUES (?, ?, ?)
`

type InsertHotelParams struct {
	Title   string `json:"title"`
	Code    string `json:"code"`
	Address string `json:"address"`
}

func (q *Queries) InsertHotel(ctx context.Context, arg InsertHotelParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, InsertHotel, arg.Title, arg.Code, arg.Address)
}

const UpdateHotel = `-- name: UpdateHotel :exec
UPDATE hotels
SET
    title = COALESCE(?, title),
    code = COALESCE(?, code),
    address = COALESCE(?, address),
    updated_at = NOW()
WHERE id = ? AND is_deleted = 0
`

type UpdateHotelParams struct {
	Title   sql.NullString `json:"title"`
	Code    sql.NullString `json:"code"`
	Address sql.NullString `json:"address"`
	ID      uint32         `json:"id"`
}

func (q *Queries) UpdateHotel(ctx context.Context, arg UpdateHotelParams) error {
	_, err := q.db.ExecContext(ctx, UpdateHotel,
		arg.Title,
		arg.Code,
		arg.Address,
		arg.ID,
	)
	return err
}
